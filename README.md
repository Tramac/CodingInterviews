# 剑指offer解答
----
在这里记录一下剑指offer的答案吧。<br>
其实很多只是比对着书本敲下来的。<br>
大约看了两遍可总是会忘，或许是根本就没有理解解题方法吧。<br>
c++真的是好难啊，更难的或许是算法吧，总是无法搞定递归，无法搞定树。<br>
总之，还是记录下来好了，就多看几遍吧，慢慢补充理解好了。<br>
### 1：[赋值运算符函数](https://github.com/Tramac/CodingInterviews/blob/master/01_AssignmentOperator/main.cpp)
* 把返回值的类型声明为该类型的引用，并在函数结束前返回实例自身的引用（即*this）。只有返回一个引用，才可以允许连续赋值。
* 把传入的参数的类型声明为常量引用。
* 判断传入的参数和当前的实例（*this）是否为同一个实例。
* 释放实例自身已有的内存。
* 注意如何释放自身内存，如何分配新的空间，如何实现字符串的赋值。
### 3：[二维数组中的查找](https://github.com/Tramac/CodingInterviews/tree/master/03_FindInPartiallySortedMatrix)
* 数组代替二维数组。
* 注意边界条件，循环的停止条件。
### 4：[替换空格](https://github.com/Tramac/CodingInterviews/tree/master/04_ReplaceBlank)
* 传入的length并不是字符串长度，只是字符串的最大容量。
* 字符串的长度需要计算。
* 注意判断新的字符串的长度是否会大于最大容量。
### 5：[从尾到头打印链表](https://github.com/Tramac/CodingInterviews/tree/master/05_PrintListReversedOrder)
* 在链表的插入与删除操作中，传入的pHead需要是一个指向指针的指针，因为有可能对pHead作出更改。
* 插入与删除操作中，首先要判断插入或删除的是否为头结点。
* 插入新结点时需要先分配内存，ListNode* pNew = new ListNode();
* 可以用栈实现从尾到头打印链表，也可以用递归实现。
### 6：[重建二叉树](https://github.com/Tramac/CodingInterviews/tree/master/06_ConstructBinaryTree)
* 熟悉二叉树中递归的使用。
* 使用四个指针。
* 由先序遍历确定根节点的值，创建根节点。
* 注意判断序列中是否只有一个元素，并且输入是否合法。
* 在中序遍历中寻找根节点，判断是否找到了根节点。
* 找到根节点后，判断是否有左子树（通过元素个数判断），如果有，递归调用求左子树的根节点。
* 同理判断右子树。
### 7：[用两个栈实现队列](https://github.com/Tramac/CodingInterviews/tree/master/07_QueueWithTwoStacks)
* 熟悉两个栈实现队列的逻辑。
* 模板的使用。
* 栈的压入与弹出，栈顶元素的获取。push(T), pop(),top()。
* 栈的大小的获取。stack.size()。
### 8：[旋转数组的最小数字](https://github.com/Tramac/CodingInterviews/tree/master/08_MinNumberInRotatedArray)
* 熟悉二分查找的思想。
* 注意旋转0个元素的特殊情况以及解决方法(将indexmin初始化为0)。
* 注意中间元素与两侧元素相等时的特殊情况，此时需要添加顺序查找。
### 9: [斐波那契数列](https://github.com/Tramac/CodingInterviews/tree/master/09_Fibonacci)
* 熟悉递归的思想。
* 递归代码简洁，但效率较低，并且容易栈溢出。
* 熟悉实用的Fibnacci的求解方法。
* 数值类型注意用long long型。
### 10.[二进制中1的个数](https://github.com/Tramac/CodingInterviews/tree/master/10_NumberOf1)
* 如果将输入的数字右移与1作与运算可能导致陷入死循环。
* 将1左移与输入的数字做与运算是一种解法。注意while循环的停止条件。
* 新颖的解法：把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变为0。
### 11.[数值的整数次方](https://github.com/Tramac/CodingInterviews/tree/master/11_Power)
* 设置全局变量，判断输入是否有效。
* 注意base为0，指数为负数的特殊情况。
* 注意判断两个小数是否相等时的函数。
### 12：[打印1到最大的n位数](https://github.com/Tramac/CodingInterviews/tree/master/12_Print1ToMaxOfNDigits)
* 该问题为大数问题，用字符串或者数组表达大数解决。
* 字符串的初始化，memset()的使用。
* 熟悉字符串表达的数字上模拟加法。判断是否溢出，是否进位。字符间的计算。
* 把字符串表达的数字打印出来。开头的0不打印，设置bool变量判断。
### 13.[在O(1)时间删除链表结点]()
* 从链表的头结点开始，顺序遍历查找要删除的结点的时间复杂度为O(n)。
* 可以把要删除结点的下一个结点的内容复制到需要删除的结点上覆盖原有的内容，再把下一个结点删除。此时的时间复杂度为O(1)。
* 如果要删除的结点位于链表的尾部，仍然要从链表的头结点开始，顺序遍历得到该结点的前序结点，并完成删除操作。
* 如果链表中只有一个结点，删除的既是头结点也是尾结点，所以传入的需要是指向头结点的指针而不是头结点，即指针的指针。
* 结点的删除操作。delete pNode; pNode = NULL;
* 理清情况分类：删除的不是尾结点，链表只有一个结点，删除的为头结点也是尾结点，链表有多个结点，删除的是尾结点。
### 14.[调整数组顺序使得奇数位于偶数前面]()
* 设置两个指针，第一个从前往后pBegin，第二个从后往前pEnd。
* 三个while循环。其中两个寻找奇数和偶数。
* 注意每次操作时需要判断pBegin < pEnd。
* 了解可扩展性。
### 15.[链表中倒数第k个结点]()
* 为了实现只遍历一次链表，定义两个指针，第一个指针从链表的头指针开始向前走k-1,第二个指针保持不动，从第k步开始，两个指针同时前进，当第一个指针到达末尾时，第二个指针正好指向倒数第k个结点。
* 注意判断传入的是否为空链表，k值是否大于链表的长度。
* 相关题目有：求链表额中间节点(一个指针走两步，另一个走一步)。判断一个单向链表是否形成了环形结构(一个指针走一步，另一个走两步，是否会相遇)。
### 16.[反转链表]()
* 需要三个指针，分别指向当前结点，前一个结点，后一个结点。
* 当后一个结点为空时，那么当前结点就是反转后的头结点，记得顺表将其设为头结点。
* 递归反转链表也要熟悉（没看懂，还要再看）。
### 17.[合并两个排序的链表]()
* 首先处理其中一个是空链表时的情况。
* 返回的是合并后的新的头结点，所以要声明新的头结点。
* 头结点的下一个结点由递归获得。
* 典型的递归题目，要多看。
### 18.[树的子结构]()
* 首先判断两个结构的根节点是否相同。
* 如果根节点相同，定义判断子树是否相同的函数，递归判断左子树根节点和右子树根节点时候同时相同。
* 如果根节点不相同，递归判断左子树和右子树是否相同。
* 注意边界条件的检查，当两个数为空的时候，定义相应的输出。
* 树结构典型的递归题，多看。
### 19.[二叉树的镜像]()
* 熟悉求镜像的过程。
* 交换两个结点的方式和交换两个常数的方式相同。
* 递归调用交换左子树和右子树。
### 20.[顺时针打印矩阵]()
* 按圈打印。
* 按圈打印的循环继续条件columns>startX*2 && rows>startY*2。
* 按圈打印分四步，熟悉每步的执行条件。
### 21.[包含min函数的栈]()
* 设置一个数据栈，一个辅助栈。压入元素时，辅助栈每次压入之前最小值和压入数据之间的较小值。
* 删除操作同时删除栈顶元素。
* 去最小值时返回辅助栈的栈顶元素即可。
* 熟悉模板的定义及声明，使用。
* 注意判断栈的size()是否为空。
### 22.[栈的压入、弹出序列]()
* 需要一个辅助栈。
* 如果下一个弹出的数字刚好是栈顶元素，那么直接弹出，如果下一个弹出的数字不在栈顶，把压栈序列中还没有入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止。如果所有的数字都压入栈了仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列。
* 熟悉逻辑以及栈的操作。
* 我觉得这道题在栈的题目中挺重要的，多看多看。
### 23:[从上往下打印二叉树]()
* 广度优先遍历二叉树问题，用队列作为辅助数据结构。
* STL中队列容器deque,入队操作push_back(),取队首元素front(),弹出队首元素pop_front()，判断队列是否为空size()是否为0。
* 首先将根节点压入队列，while循环，弹出队结点并打印，然后判断该是否有左右子结点，如果有依次压入队列，如果队列为空结束循环。
### 24.[二叉搜索树的后序遍历序列]()
* 二叉搜索树的左子树结点的值均小于根节点，右子树结点的值均大于根节点。
* 后序遍历的最后一个数字是树的根节点的值。
* 首先确定根节点的值（即序列最后一个数）。
* 设i=0,从头遍历二叉搜索树的左子树（即判断结点值是否小于根节点），得到左子树最后结点的索引i。
* 设j=i,从左子树最后索引i开始到length-1,此部分应该是右子树，遍历是否全部大于根节点，如果不满足，则无法构成二叉搜索树,返回false。
* 如果都满足，当i>0,递归调用左子树。当j<length-1，递归调用右子树。返回left&&right。
